function oSettings = AllSettings()
% Defines all settings used by the Baxter Algorithms.
%
% This function specifies all of the settings which affect the processing
% done by the Baxter Algorithms, as objects of the class Setting. This
% defines everything necessary to generate GUIs, where the user can specify
% values for the settings, using the class SettingsPanel. The default
% values for the settings are specified here, but the actual values which
% will be used for processing are specified by the user and are then stored
% in csv-files which are read into objects of the class ImageData before
% the processing starts. Each image sequence has its own set of settings
% values.
%
% For processing of any given image sequence, only a subset of the settings
% defined here will be used, since many of them have an effect only if some
% other setting is set to a particular value. For example, there are
% settings which are specific to a particular segmentation algorithm and
% only one of the segmentation algorithms is used to process an image
% sequence. The idea is that only the settings which will affect the
% results should be shown to the user. Therefore many of the settings
% objects have a visiblefunction, which determines if the setting should be
% shown to the user, based on the values of other settings.
%
% The settings are grouped into the following categories:
% image - Settings describing the image sequence.
% segmentation - Defines how the outlines of the cells are found.
% tracking - Defines how the detected outlines are linked into tracks.
% analysis - Settings defining how the tracking data should be analyzed.
%
% The settings also belong to one of the following levels:
% 'basic' - Sufficient to process most image sequences.
% 'advanced'  - Can be important in order to get better performance.
% 'development' - Are only meant for development.
% 'hidden - Rarely used settings which should not be changed.
%
% It is possible to have a setting automatically altered when some other
% setting is changed. To do this, the default value of the altered setting
% needs to be defined using a function handle, as described in the Settings
% class, so that the default value depends on the other setting. Whenever
% the default value changes, the setting will be set to the new default
% value, if the label of the setting is included in the 'alters' field of
% the other setting.
%
% The settings definitions in this file are always the same for all calls
% to the function, and they should not be changed when the program is
% running. Therefore the output is cashed to reduce processing. The second
% time the function is called, the Map of settings which was returned
% the first time is cloned, and then the cloned object is returned. The
% settings objects themselves are not cloned.
%
% All of the settings names are valid field names for structs, and
% therefore the settings names themselves are used as labels in the
% Map returned by this function.
%
% There are a number of functions at the end of this file, which are used
% to define function handles for the construction of the settings objects.
% Most of the functions determine which values should be considered valid
% for the settings. The remaining functions determine when control objects
% associated with the settings should be visible.
%
% Outputs:
% oSettings - Map with all settings used by the Baxter Algorithms.
%
% See also:
% Setting, SettingsPanel, SettingsGUI, Map, ImageParameters,
% ImageData

% Cached Map previously returned as oSettings.
persistent output

if ~isempty(output)
    % Clone a master copy of the settings, without cloning the settings
    % objects themselves.
    oSettings = output.Clone();
    
    % Update available point spread functions.
    psfs = GetNames(FindFile('PSFs'), 'mat');
    oSettings.Get('PCSegPSF').SetAlternatives('development', psfs)
    
    % Update available segmentation templates.
    templates = GetNames(FindFile('Templates'), 'mat');
    oSettings.Get('TMSegTemplate').SetAlternatives('advanced', templates)
    
    % Update available classifiers.
    clPath = FindFile('Classifiers');
    countCl = [{'none'}; GetNames(fullfile(clPath, 'Count'), 'mat')];
    splitCl = [{'none'}; GetNames(fullfile(clPath, 'Split'), 'mat')];
    deathCl = [{'none'}; GetNames(fullfile(clPath, 'Death'), 'mat')];
    migrationCl = [{'none'}; GetNames(fullfile(clPath, 'Migration'), 'mat')];
    oSettings.Get('countClassifier').SetAlternatives('advanced', countCl)
    oSettings.Get('splitClassifier').SetAlternatives('advanced', splitCl)
    oSettings.Get('deathClassifier').SetAlternatives('advanced', deathCl)
    oSettings.Get('migClassifier').SetAlternatives('advanced', migrationCl)
    
    return
end

% Image settings.

sett.numZ = Setting(...
    'name', 'numZ',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'image',...
    'level', 'advanced',...
    'alters', {'SegAlgorithm'; 'SegCellMorphMask'; 'PCSegPSF'; 'PCSegBeta';...
    'PCSegIterations'; 'PCSegPSFSizeXY'; 'PCSegPSFSizeZ'},...
    'checkfunction', @IsNonNegativeInteger,...
    'tooltip', 'The number of z-planes in 3D data. This should be 1 for 2D data.');

sett.zStacked = Setting(...
    'name', 'zStacked',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'image',...
    'level', 'advanced',...
    'checkfunction', @IsBinary,...
    'visiblefunction', @(x) x.GetDim() == 3,...
    'tooltip', 'Set to 1 if the files are tif stacks with multiple z-planes.');

sett.bits = Setting(...
    'name', 'bits',...
    'default', 8,...
    'type', 'numeric',...
    'category', 'image',...
    'level', 'basic',...
    'checkfunction', @IsPositiveInteger,...
    'tooltip', 'The number of bits used by the camera.');

sett.voxelHeight = Setting(...
    'name', 'voxelHeight',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'image',...
    'level', 'advanced',...
    'checkfunction', @IsPositive,...
    'visiblefunction', @(x) x.GetDim() == 3,...
    'tooltip', 'The ratio between the height and width of voxels in 3D data.');

sett.minWellR = Setting(...
    'name', 'minWellR',...
    'default', nan,...
    'type', 'numeric',...
    'category', 'image',...
    'level', 'advanced',...
    'checkfunction', @(x) strcmpi(x, 'nan') || IsNonNegative(x),...
    'tooltip', ['Smallest possible microwell radius in pixels. Set to '...
    'nan if there are no microwells.']);

sett.maxWellR = Setting(...
    'name', 'maxWellR',...
    'default', nan,...
    'type', 'numeric',...
    'category', 'image',...
    'level', 'advanced',...
    'checkfunction', @(x) strcmpi(x, 'nan') || IsNonNegative(x),...
    'tooltip', ['Largest possible microwell radius in pixels. Set to '...
    'nan if there are no microwells.']);

sett.channelNames = Setting(...
    'name', 'channelNames',...
    'default', 'Ch1',...
    'type', 'char',...
    'category', 'image',...
    'level', 'advanced',...
    'alters', {'SegChannel'},...
    'checkfunction', @NotEmpty,...
    'tooltip', ['Names of the imaged channels, such as bright field or '...
    'GFP, separated by :.']);

sett.channelTags = Setting(...
    'name', 'channelTags',...
    'default', '.*',...
    'type', 'char',...
    'category', 'image',...
    'level', 'advanced',...
    'checkfunction', @NotEmpty,...
    'tooltip', ['Unique identifiers, such as c01 and c02, for files '...
    'belonging to the different channels, separated by :.']);

sett.channelColors = Setting(...
    'name', 'channelColors',...
    'default', '1 1 1',...
    'type', 'char',...
    'category', 'image',...
    'level', 'advanced',...
    'checkfunction', @NotEmpty,...
    'tooltip', ['RGB color triplets with values between 0 and 1, for '...
    'the different colors, separated by :.']);

sett.channelMin = Setting(...
    'name', 'channelMin',...
    'default', '0',...
    'type', 'char',...
    'category', 'image',...
    'level', 'advanced',...
    'checkfunction', @NotEmpty,...
    'tooltip', ['Threshold, below which all pixels will be black, as a '...
    'fraction of the dynamic range. If there are multiple channels, '...
    'the different values are separated by :.']);

sett.channelMax = Setting(...
    'name', 'channelMax',...
    'default', '1',...
    'type', 'char',...
    'category', 'image',...
    'level', 'advanced',...
    'checkfunction', @NotEmpty,...
    'tooltip', ['Threshold, above which all pixels will be white, as a '...
    'fraction of the dynamic range. If there are multiple channels, '...
    'the different values are separated by :.']);

sett.use = Setting(...
    'name', 'use',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'image',...
    'level', 'advanced',...
    'checkfunction', @IsBinary,...
    'tooltip', ['If this is set to 0, the image sequence will not be '...
    'processed or included in any analysis.']);

sett.sequenceLength = Setting(...
    'name', 'sequenceLength',...
    'default', [],...
    'type', 'numeric',...
    'category', 'image',...
    'level', 'development',...
    'checkfunction', @(x) isempty(x) || IsPositiveInteger(x),...
    'tooltip', ['Maximum number of images to process per sequence. '...
    'Leave empty to process all images.']);

% Segmentation settings.

sett.SegOldVersion = Setting(...
    'name', 'SegOldVersion',...
    'default', 'none',...
    'alternatives_advanced', @(aImSett) ['none'; GetVersions(aImSett.seqPath)'],...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'tooltip', ['Previously computed segmentation to load instead of '...
    'computing a new one.']);

sett.SegSave = Setting(...
    'name', 'SegSave',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'checkfunction', @IsBinary,...
    'tooltip', ['Set this to 1 to save intermediate segmentation '...
    'results so that the processing can be resumed later.']);

sett.SegGbRamPerFrameCTC = Setting(...
    'name', 'SegGbRamPerFrameCTC',...
    'default', 16,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'checkfunction', @IsPositive,...
    'tooltip', ['The RAM memory (in GB) required to segment one frame. '...
    'Used to select the number of frames to segment in parallel in '...
    'the CTCs.']);

sett.SegNumBlocks = Setting(...
    'name', 'SegNumBlocks',...
    'default', [1 1 1],...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) && x.GetDim() == 3,...
    'checkfunction', @(x)IsNonNegativeIntegerArray(x, 3, 3),...
    'tooltip', ['The number of blocks that each dimension of the image '...
    'is broken into before segmentation is applied. [yN, xN, zN]']);

sett.SegBlockMargin = Setting(...
    'name', 'SegBlockMargin',...
    'default', 50,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) && x.GetDim() == 3 && any(x.Get('SegNumBlocks') > 1),...
    'checkfunction', @(x)IsNonNegativeInteger(x),...
    'tooltip', ['The number of voxels added on each side of the '...
    'segmentation blocks to avoid edge effects.']);

basicSegAlgs2D = {...
    'Segment_threshold'
    'Segment_bandpass'
    'Segment_localvariance'
    'Segment_fibers'};
advancedSegAlgs2D = {...
    'Segment_import'
    'Segment_import_binary'
    'Segment_template'};
developmentSegAlgs2D = {...
    'Segment_precondPSF'
    'Segment_ridgeconnection'};

basicSegAlgs3D = {...
    'Segment_threshold3D'
    'Segment_bandpass3D'};
advancedSegAlgs3D = {...
    'Segment_import'
    'Segment_import_binary'};
developmentSegAlgs3D = {...
    'Segment_precondPSF3D'};

sett.SegAlgorithm = Setting(...
    'name', 'SegAlgorithm',...
    'default', @(x) Conditional(x.GetDim()==2, 'Segment_bandpass', 'Segment_bandpass3D'),...
    'alternatives_basic', @(x) Conditional(x.GetDim()==2, basicSegAlgs2D, basicSegAlgs3D),...
    'alternatives_advanced', @(x) Conditional(x.GetDim()==2,...
    Conditional(~isempty(x.GetSegImportFolders()), advancedSegAlgs2D,...
    setdiff(advancedSegAlgs2D, {'Segment_import'; 'Segment_import_binary'})),...
    Conditional(~isempty(x.GetSegImportFolders()), advancedSegAlgs3D,...
    setdiff(advancedSegAlgs3D, {'Segment_import'; 'Segment_import_binary'}))),...
    'alternatives_development', @(x) Conditional(x.GetDim()==2,...
    developmentSegAlgs2D, developmentSegAlgs3D),...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) strcmp(x.Get('SegOldVersion'), 'none'),...
    'tooltip', ['Segmentation algorithm to use. Try '...
    'Segment_localvariance for transmission microscopy, '...
    'Segment_bandpass for fluorescence microscopy and Segment_fibers '...
    'for muscle histology.']);

% The channelNames property of ImageParameters is not yet defined, so we
% need to use the colon spearated string instead.
sett.SegChannel = Setting(...
    'name', 'SegChannel',...
    'default', @(x) GetIndex(strtrim(regexpi(x.Get('channelNames'), ':', 'split')'), 1),...
    'alternatives_basic', @(x) strtrim(regexpi(x.Get('channelNames'), ':', 'split')'),...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @NotLoad,...
    'tooltip', 'Imaging channel that will be used for segmentation.');

sett.SegLightCorrect = Setting(...
    'name', 'SegLightCorrect',...
    'default', 'none',...
    'alternatives_advanced', {'none'; 'additive'},...
    'alternatives_development', {'multiplicative'; 'sequencerange'},...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @NotLoad,...
    'tooltip', 'Method used to normalize the image intensity.');

sett.SegBgSubAlgorithm = Setting(...
    'name', 'SegBgSubAlgorithm',...
    'default', 'none',...
    'alternatives_basic', {'none'; 'BgSub_median'; 'BgSub_min'},...
    'alternatives_development', {'BgSub_medianfit'},...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @NotLoad,...
    'tooltip', ['Background subtraction algorithm. Use BgSub_median '...
    'for transmission microscopy and BgSub_min for fluorescence images']);

sett.SegMediaChanges = Setting(...
    'name', 'SegMediaChanges',...
    'default', [],...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi({'BgSub_median' 'BgSub_medianfit'}, x.Get('SegBgSubAlgorithm'))),...
    'checkfunction', @(x)IsPositiveIntegerArray(x, 0, inf),...
    'tooltip', 'Image indices directly following media changes, separated by spaces.');

sett.SegBgSubAtten = Setting(...
    'name', 'SegBgSubAtten',...
    'default', 5,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) && ~strcmp(x.Get('SegBgSubAlgorithm'), 'none'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Attenuation of regions with high background values. '...
    'Larger values remove more background.']);

sett.SegTopHatRadius = Setting(...
    'name', 'SegTopHatRadius',...
    'default', inf,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x),...
    'checkfunction', @IsPositive,...
    'tooltip', ['Radius of disk used for (2D) top-hat filtering to '...
    'remove non-uniform illumination. Inf means no filtering.']);

sett.SegFillHoles = Setting(...
    'name', 'SegFillHoles',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @NotLoad,...
    'checkfunction', @IsBinary,...
    'tooltip', 'Binary parameter for removal of holes in the segmented regions.');

sett.SegMinHoleArea = Setting(...
    'name', 'SegMinHoleArea',...
    'default', inf,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) && x.Get('SegFillHoles'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Holes with an area smaller than this value are removed.');

sett.SegMinArea = Setting(...
    'name', 'SegMinArea',...
    'default', 40,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @NotLoad,...
    'checkfunction', @IsNonNegativeInteger,...
    'tooltip', 'Regions with fewer pixels will be removed.');

sett.SegMaxArea = Setting(...
    'name', 'SegMaxArea',...
    'default', inf,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @NotLoad,...
    'checkfunction', @IsNonNegativeInteger,...
    'tooltip', 'Regions with more pixels will be removed.');

sett.SegMinSumIntensity = Setting(...
    'name', 'SegMinSumIntensity',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @NotLoad,...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Regions with a summed image intensity below this '...
    'threshold will be removed.']);

sett.SegClipping = Setting(...
    'name', 'SegClipping',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @NotLoad,...
    'checkfunction', @IsBetween0and1,...
    'tooltip', ['Threshold for intensity clipping between 0 and 1. '...
    'Pixels with higher values will be set to the threshold.']);

sett.SegClippingBelow = Setting(...
    'name', 'SegClippingBelow',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @NotLoad,...
    'checkfunction', @IsBetween0and1,...
    'tooltip', ['Threshold from below for intensity clipping. The value '...
    'is subtracted from the image, negative values are set to 0.']);

sett.SegSmooth = Setting(...
    'name', 'SegSmooth',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @NotLoad,...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Standard deviation of a Gaussian smoothing kernel '...
    'applied before the segmentation. Larger values give smoother regions.']);

sett.SegMedFilt = Setting(...
    'name', 'SegMedFilt',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @NotLoad,...
    'checkfunction', @(x) IsNonNegativeIntegerArray(x,1,3) && all(rem(str2num(x),2) == 1),...
    'tooltip', ['If this is N, an NxN median filter will be used to '...
    'remove noise. N needs to be an odd integer.']); %#ok<ST2NM>

sett.SegWatershed = Setting(...
    'name', 'SegWatershed',...
    'default', 'none',...
    'alternatives_basic', {'none'; 'shape'; 'intermediate'},...
    'alternatives_advanced', {'anisotropicshape'; 'planeshape'; 'brightness'; 'darkness'},...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @NotLoad,...
    'tooltip', ['Image parameter used in a seeded watershed transform '...
    'for separation of cells in clusters.']);

sett.SegWSmooth = Setting(...
    'name', 'SegWSmooth',...
    'default', 7,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) && ~strcmp(x.Get('SegWatershed'), 'none'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Standard deviation of a Gaussian smoothing kernel '...
    'applied before the watershed transform. Larger values create '...
    'fewer fragments.']);

sett.SegWHMax = Setting(...
    'name', 'SegWHMax',...
    'default', 0.1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) && ~strcmp(x.Get('SegWatershed'), 'none'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Removes local watershed minima with a depth, relative '...
    'to the surrounding, below this value. Larger values create fewer fragments.']);

sett.SegWThresh = Setting(...
    'name', 'SegWThresh',...
    'default', -inf,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) && ~strcmp(x.Get('SegWatershed'), 'none'),...
    'checkfunction', @IsNumeric,...
    'tooltip', ['Removes local watershed minima with an absolute depth '...
    'below this value. Larger values create fewer fragments.']);

sett.SegWUpSampling = Setting(...
    'name', 'SegWUpSampling',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    ~strcmp(x.Get('SegWatershed'), 'none') && x.GetDim()==3,...
    'checkfunction', @IsPositiveInteger,...
    'tooltip', ['Rate by which the z-dimension of a z-stack will be '...
    'up-sampled to avoid problems in the watershed transform when the '...
    'z-planes are far apart.']);

sett.SegWatershed2 = Setting(...
    'name', 'SegWatershed2',...
    'default', 'none',...
    'alternatives_basic', {'none'; 'shape'; 'intermediate'},...
    'alternatives_advanced', {'anisotropicshape'; 'planeshape'; 'brightness'; 'darkness'},...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    (~strcmp(x.Get('SegWatershed'), 'none') || ~strcmp(x.Get('SegWatershed2'), 'none')),...
    'tooltip', ['Image parameter used in a second seeded watershed '...
    'transform used for further separation of cells in clusters.']);

sett.SegWSmooth2 = Setting(...
    'name', 'SegWSmooth2',...
    'default', 7,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) && ~strcmp(x.Get('SegWatershed2'), 'none'),...
    'checkfunction', @IsNonNegative,....
    'tooltip', ['Standard deviation of a Gaussian smoothing kernel '...
    'applied before the second watershed transform. Larger values '...
    'create fewer fragments.']);

sett.SegWHMax2 = Setting(...
    'name', 'SegWHMax2',...
    'default', 0.1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) && ~strcmp(x.Get('SegWatershed2'), 'none'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Removes local watershed minima (in the second '...
    'transform) with an absolute depth below this value. Larger values '...
    'create fewer fragments.']);

sett.SegWThresh2 = Setting(...
    'name', 'SegWThresh2',...
    'default', -inf,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) && ~strcmp(x.Get('SegWatershed2'), 'none'),...
    'checkfunction', @IsNumeric,...
    'tooltip', ['Removes local watershed minima (in the second '...
    'transform) with an absolute depth below this value. Larger values '...
    'create fewer fragments.']);

sett.SegWUpSampling2 = Setting(...
    'name', 'SegWUpSampling2',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    ~strcmp(x.Get('SegWatershed2'), 'none') && x.GetDim()==3,...
    'checkfunction', @IsPositiveInteger,...
    'tooltip', ['Rate by which the z-dimension of a z-stack will be '...
    'up-sampled to avoid problems in the second watershed transform '...
    'when the z-planes are far apart.']);

sett.SegWLocMaxCentroids = Setting(...
    'name', 'SegWLocMaxCentroids',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) && ~strcmp(x.Get('SegWatershed'), 'none'),...
    'checkfunction', @IsBinary,...
    'tooltip', ['If this is 1, watershed minima will be used as cell '...
    'locations instead of the region centroids.']);

sett.SegCellMorphOp = Setting(...
    'name', 'SegCellMorphOp',...
    'default', 'none',...
    'alternatives_advanced', {'none'; 'close'; 'convexhull'; 'open'},...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @NotLoad,...
    'tooltip', ['A morphological operator applied to the individual '...
    'segmentation masks of the cells (not to the whole image).']);

sett.SegCellMorphMask = Setting(...
    'name', 'SegCellMorphMask',...
    'default', @(x) Conditional(x.GetDim()==2, 50, [50 50 0.5]),...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi({'close' 'open'}, x.Get('SegCellMorphOp'))),...
    'checkfunction', @(x)IsPositiveArray(x, 1, 3),...
    'tooltip', ['Semi-axis of ellipsoid structuring element for (cell) '...
    'morphological operators. A single value gives a circle in x and y '...
    'and scaling by 1/voxelHeight in z.']);

sett.LVSegRegionSize = Setting(...
    'name', 'LVSegRegionSize',...
    'default', 2,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_localvariance'),...
    'checkfunction', @IsPositiveInteger,...
    'tooltip', ['Radius of the region around each pixel, in which the '...
    'sample variance is computed. Larger values give smoother regions.']);

sett.LVSegThreshold = Setting(...
    'name', 'LVSegThreshold',...
    'default', 3,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_localvariance'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Threshold on the pixel sample variance. Larger values '...
    'make regions smaller or remove them.']);

sett.LVSegErodeSize = Setting(...
    'name', 'LVSegErodeSize',...
    'default', 3,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_localvariance'),...
    'checkfunction', @IsNonNegativeInteger,....
    'tooltip', ['A number of pixels that will be removed around the '...
    'borders of all regions, using erosion. Larger values make regions '...
    'smaller or remove them.']);

sett.LVSegRegionShape = Setting(...
    'name', 'LVSegRegionShape',...
    'default', 'square',...
    'type', 'choice',...
    'alternatives_basic', {'square'},...
    'alternatives_advanced', {'round'; 'gaussian'},...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_localvariance'),...
    'tooltip', ['The shape of the region in which the sample variance '...
    'will be computed. Square is fast and usually works well.']);

sett.LVSegErodeShape = Setting(...
    'name', 'LVSegErodeShape',...
    'default', 'square',...
    'type', 'choice',...
    'alternatives_basic', {'square'},...
    'alternatives_advanced', {'round'},...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_localvariance'),...
    'tooltip', 'The shape of the structuring element used for erosion.');

sett.TSegThreshold = Setting(...
    'name', 'TSegThreshold',...
    'default', 0.2,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi(x.Get('SegAlgorithm'), {'Segment_threshold', 'Segment_threshold3D'})),...
    'checkfunction', @IsNumeric,...
    'tooltip', ['Pixel intensity above (or below) which pixels are '...
    'considered to belong to cells.']);

sett.TSegDarkOrBright = Setting(...
    'name', 'TSegDarkOrBright',...
    'default', 'bright',...
    'alternatives_advanced', {'bright'; 'dark'},...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi(x.Get('SegAlgorithm'), {'Segment_threshold', 'Segment_threshold3D'})),...
    'tooltip', 'Specifies if the cells are brighter or darker than the threshold.');

precondAlgs = {...
    'Segment_precondPSF'
    'Segment_precondPSF3D'};

psfs = GetNames(FindFile('PSFs'), 'mat');

sett.PCSegPSF = Setting(...
    'name', 'PCSegPSF',...
    'default', @(x) Conditional(x.GetDim()==2, 'BRIGHTFIELD.mat', 'VIRUS_symmetric.mat'),...
    'alternatives_development', psfs,...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi(precondAlgs, x.Get('SegAlgorithm'))),...
    'tooltip', 'PSF used for preconditioning (deconvolution).');

sett.PCSegBeta = Setting(...
    'name', 'PCSegBeta',...
    'default', @(x) Conditional(x.GetDim()==2, 30, 50),...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'checkfunction', @IsNonNegative,...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi(precondAlgs, x.Get('SegAlgorithm'))),...
    'tooltip', 'L1 penalty in the preconditioning algorithm.');

sett.PCSegThreshold = Setting(...
    'name', 'PCSegThreshold',...
    'default', 1E-2,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'checkfunction', @IsNonNegative,...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi(precondAlgs, x.Get('SegAlgorithm'))),...
    'tooltip', 'Threshold applied to the preconditioned image.');

sett.PCSegIterations = Setting(...
    'name', 'PCSegIterations',...
    'default', @(x) Conditional(x.GetDim()==2, 10, 5),...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'checkfunction', @IsPositiveInteger,...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi(precondAlgs, x.Get('SegAlgorithm'))),...
    'tooltip', 'Number of preconditioning iterations.');

sett.PCSegPSFSizeXY = Setting(...
    'name', 'PCSegPSFSizeXY',...
    'default', @(x) Conditional(x.GetDim()==2, 20, 10),...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'checkfunction', @IsPositiveInteger,...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi(precondAlgs, x.Get('SegAlgorithm'))),...
    'tooltip', 'If this is N, the PSF will be 2*N+1 x 2*N+1 voxels in the xy-plane.');

sett.PCSegPSFSizeZ = Setting(...
    'name', 'PCSegPSFSizeZ',...
    'default', @(x) Conditional(x.GetDim()==2, 0, 4),...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi(precondAlgs, x.Get('SegAlgorithm'))),...
    'checkfunction', @IsPositiveInteger,...
    'tooltip', 'If this is N, the PSF will be 2*N+1 voxels high in the z-dimension.');

templates = GetNames(FindFile('Templates'), 'mat');
sett.TMSegTemplate = Setting(...
    'name', 'TMSegTemplate',...
    'default', 'HSC_10x_bf_21x21.mat',...
    'alternatives_advanced', templates,...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_template'),...
    'tooltip', 'Template used for segmentation by template matching.');

sett.TMSegThreshold = Setting(...
    'name', 'TMSegThreshold',...
    'default', 0.11,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_template'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Threshold on the correlation with the template.');

sett.TMSegCovThreshold = Setting(...
    'name', 'TMSegCovThreshold',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_template'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Threshold on sample covariance with the template.');

sett.TMSegMinSeparation = Setting(...
    'name', 'TMSegMinSeparation',...
    'default', 10,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_template'),...
    'checkfunction', @IsPositive,...
    'tooltip', 'Minimum separation between cell centers in pixels.');

sett.TMSegComplementAlg = Setting(...
    'name', 'TMSegComplementAlg',...
    'default', 'none',...
    'alternatives_advanced',...
    ['none'; basicSegAlgs2D; advancedSegAlgs2D; developmentSegAlgs2D],...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_template'),...
    'tooltip', ['Algorithm used as a complement to template matching, '...
    'to find cell regions that don''t match the template.']);

sett.TMSegComplementErode = Setting(...
    'name', 'TMSegComplementErode',...
    'default', 5,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_template'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['The amount of erosion applied to the binary mask '...
    'found by the complementary segmentation algorithm but not by '...
    'template matching.']);

sett.TMSegComplementOpen = Setting(...
    'name', 'TMSegComplementOpen',...
    'default', 0.5,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_template'),...
    'checkfunction', @IsPositive,...
    'tooltip', ['Radius of structuring element for opening applied to '...
    'the binary mask found by the complimentary segmentation algorithm '...
    'but not by template matching.']);

sett.FibSegBGThreshold = Setting(...
    'name', 'FibSegBGThreshold',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_fibers'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Intensity threshold below which pixels are considered '...
    'to belong to the background.']);

sett.FibSegMergeThreshold = Setting(...
    'name', 'FibSegMergeThreshold',...
    'default', 3,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_fibers'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Intensity ratio threshold for merging of adjacent '...
    'regions. Decreasing this value will merge more regions.']);

sett.FibSegMedFiltSize = Setting(...
    'name', 'FibSegMedFiltSize',...
    'default', 5,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_fibers'),...
    'checkfunction', @(x) IsPositiveInteger(x) && rem(str2double(x),2) == 1,...
    'tooltip', ['If this is N, an NxN median filter will be used to '...
    'remove noise before cracks between fibers are identified. N needs '...
    'to be an odd integer.']);

sett.FibSegSmallestCrack = Setting(...
    'name', 'FibSegSmallestCrack',...
    'default', 20,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_fibers'),...
    'checkfunction', @IsNonNegativeInteger,...
    'tooltip', 'Holes in the tissue consisting of fewer pixels are filled.');

sett.FibSegSmallestUnmerged = Setting(...
    'name', 'FibSegSmallestUnmerged',...
    'default', 250,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_fibers'),...
    'checkfunction', @IsNonNegativeInteger,...
    'tooltip', ['Regions with fewer pixels will be merged into '...
    'neighboring regions even if the other merging criteria are not met.']);

sett.FibSegSmallestHole = Setting(...
    'name', 'FibSegSmallestHole',...
    'default', 5000,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_fibers'),...
    'checkfunction', @IsNonNegativeInteger,...
    'tooltip', 'Removes holes in fibers with fewer pixels.');

sett.FibSegImOpenRadius = Setting(...
    'name', 'FibSegImOpenRadius',...
    'default', 5,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_fibers'),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Radius for morphological opening of the fiber regions. '...
    'Larger value give smoother fiber outlines.']);

sett.FibSegShapeHmin = Setting(...
    'name', 'FibSegShapeHmin',...
    'default', 5,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi(x.Get('SegAlgorithm'), 'Segment_fibers'),...
    'checkfunction', @(x) IsNonNegative(x) || strcmpi(x, 'nan'),...
    'tooltip', ['Small values split fibers that are not convex. Set '...
    'this to nan if you don''t want to split any fibers.']);

sett.BPSegHighStd = Setting(...
    'name', 'BPSegHighStd',...
    'aliases', {'BPSegHightStd'},...
    'default', 5,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi({'Segment_bandpass' 'Segment_bandpass3D'}, x.Get('SegAlgorithm'))),...
    'checkfunction', @(x)IsNonNegativeArray(x, 1, 2),...
    'tooltip', ['Standard deviation of the Gaussian kernel used to '...
    'compute the background image. Usually between 5 and 1000.']);

sett.BPSegLowStd = Setting(...
    'name', 'BPSegLowStd',...
    'default', 2,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi({'Segment_bandpass' 'Segment_bandpass3D'}, x.Get('SegAlgorithm'))),...
    'checkfunction', @(x)IsNonNegativeArray(x, 1, 2),...
    'tooltip', ['Factor multiplying the bandpass filtering background '...
    'image before it is subtracted.']);

sett.BPSegBgFactor = Setting(...
    'name', 'BPSegBgFactor',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi({'Segment_bandpass' 'Segment_bandpass3D'}, x.Get('SegAlgorithm'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Factor multiplying the bandpass filtering background '...
    'image before it is subtracted.']);

sett.BPSegThreshold = Setting(...
    'name', 'BPSegThreshold',...
    'default', 0.003,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'basic',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi({'Segment_bandpass' 'Segment_bandpass3D'}, x.Get('SegAlgorithm'))),...
    'checkfunction', @IsNumeric,...
    'tooltip', ['Threshold for the bandpass filtered image. Larger '...
    'values make the regions smaller or remove them.']);

sett.BPSegDarkOrBright = Setting(...
    'name', 'BPSegDarkOrBright',...
    'default', 'bright',...
    'alternatives_advanced', {'bright'; 'dark'},...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction', @(x) NotLoad(x) &&...
    any(strcmpi({'Segment_bandpass' 'Segment_bandpass3D'}, x.Get('SegAlgorithm'))),...
    'tooltip', 'Specifies if the cells are brighter or darker than the threshold.');

sett.CorSegThreshold = Setting(...
    'name', 'CorSegThreshold',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi('Segment_corners', x.Get('SegAlgorithm')),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Threshold for the preconditioned image.');

sett.RCSegSmooth = Setting(...
    'name', 'RCSegSmooth',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi('Segment_ridgeconnection', x.Get('SegAlgorithm')),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Smoothing used to merge ridges of different scales.');

sett.RCSegAlpha = Setting(...
    'name', 'RCSegAlpha',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi('Segment_ridgeconnection', x.Get('SegAlgorithm')),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Weight associated with the ratio of eigenvalues.');

sett.RCSegBeta = Setting(...
    'name', 'RCSegBeta',...
    'default', 10,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi('Segment_ridgeconnection', x.Get('SegAlgorithm')),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Weight associated with the norm of the eigenvalue vector.');

sett.RCSegScaling = Setting(...
    'name', 'RCSegScaling',...
    'default', 20,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi('Segment_ridgeconnection', x.Get('SegAlgorithm')),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Scaling factor for a asinh transform.');

sett.RCSegThreshold = Setting(...
    'name', 'RCSegThreshold',...
    'default', 0.75,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi('Segment_ridgeconnection', x.Get('SegAlgorithm')),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Ridge threshold relative to the mean ridge intensity.');

sett.RCSegMaxDist = Setting(...
    'name', 'RCSegMaxDist',...
    'default', 50,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi('Segment_ridgeconnection', x.Get('SegAlgorithm')),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Maximum gap size that can be closed in the ridge skeleton.');

sett.RCSegMinArea = Setting(...
    'name', 'RCSegMinArea',...
    'default', 7500,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi('Segment_ridgeconnection', x.Get('SegAlgorithm')),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Minimum size of cell fragments that can be created using gap closing.');

sett.RCSegMinVar = Setting(...
    'name', 'RCSegMinVar',...
    'default', 5E-4,...
    'type', 'numeric',...
    'category', 'segmentation',...
    'level', 'development',...
    'visiblefunction', @(x) NotLoad(x) &&...
    strcmpi('Segment_ridgeconnection', x.Get('SegAlgorithm')),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Minimum variance of cell regions. Other regions are '...
    'classified as background.']);

sett.SegImportFolder = Setting(...
    'name', 'SegImportFolder',...
    'default', @(x) GetIndex(x.GetSegImportFolders(), 1),...
    'alternatives_advanced', @(x) x.GetSegImportFolders(),...
    'type', 'choice',...
    'category', 'segmentation',...
    'level', 'advanced',...
    'visiblefunction',...
    @(x) any(strcmpi({'Segment_import' 'Segment_import_binary'}, x.Get('SegAlgorithm'))),...
    'tooltip', ['Name of folder (in the Analysis folder) containing '...
    '16-bit label tifs with a segmentation that should be imported.']);

% Tracking settings.

sett.TrackXSpeedStd = Setting(...
    'name', 'TrackXSpeedStd',...
    'default', 12,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'basic',...
    'checkfunction', @(x)IsPositiveArray(x, 1, 2),...
    'tooltip', ['Standard deviation (in pixels per frame) of cell '...
    'displacements in the x- and y-directions.']);

sett.TrackZSpeedStd = Setting(...
    'name', 'TrackZSpeedStd',...
    'default', 12,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'basic',...
    'visiblefunction', @(x) x.GetDim() == 3,...
    'checkfunction', @(x) IsPositiveArray(x, 1, 2),...
    'tooltip', ['Standard deviation (in pixel widths per frame) of '...
    'cell displacement in the z-direction of a 3D image sequence.']);

% TODO: Add .mat to all classifier names.

% Path where all classifiers are stored.
clPath = FindFile('Classifiers');

% TODO: Put some of the classifiers as development options.
countCl = [{'none'}; GetNames(fullfile(clPath, 'Count'), 'mat')];
sett.countClassifier = Setting(...
    'name', 'countClassifier',...
    'default', 'none',...
    'alternatives_advanced', countCl,...
    'type', 'choice',...
    'category', 'tracking',...
    'level', 'advanced',...
    'tooltip', ['Classifier used to estimate the number of cells in '...
    'segmented regions.']);

% TODO: Put some of the classifiers as development options.
splitCl = [{'none'}; GetNames(fullfile(clPath, 'Split'), 'mat')];
sett.splitClassifier = Setting(...
    'name', 'splitClassifier',...
    'default', 'none',...
    'alternatives_advanced', splitCl,...
    'type', 'choice',...
    'category', 'tracking',...
    'level', 'advanced',...
    'tooltip', ['Classifier used to estimate the probability of '...
    'mitosis in segmented regions.']);

% TODO: Put some of the classifiers as development options.
deathCl = [{'none'}; GetNames(fullfile(clPath, 'Death'), 'mat')];
sett.deathClassifier = Setting(...
    'name', 'deathClassifier',...
    'default', 'none',...
    'alternatives_advanced', deathCl,...
    'type', 'choice',...
    'category', 'tracking',...
    'level', 'advanced',...
    'tooltip', ['Classifier used to estimate the probability of '...
    'apoptosis in segmented regions.']);

% TODO: Check if this should be included.
migrationCl = [{'none'}; GetNames(fullfile(clPath, 'Migration'), 'mat')];
sett.migClassifier = Setting(...
    'name', 'migClassifier',...
    'default', 'none',...
    'alternatives_development', migrationCl,...
    'type', 'choice',...
    'category', 'tracking',...
    'level', 'hidden',...
    'tooltip', ['Classifier used to estimate the probability of '...
    'migration between detections.']);

sett.pCnt0 = Setting(...
    'name', 'pCnt0',...
    'default', 0.2,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'basic',...
    'visiblefunction', @(x) strcmp(x.Get('countClassifier'), 'none'),...
    'checkfunction', @IsBetween0and1,...
    'tooltip', ['Fixed probability that segmented regions contain 0 '...
    'cells, used only if countClassifier is set to none.']);

sett.pCnt1 = Setting(...
    'name', 'pCnt1',...
    'default', 0.7,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'basic',...
    'visiblefunction', @(x) strcmp(x.Get('countClassifier'), 'none'),...
    'checkfunction', @IsBetween0and1,...
    'tooltip', ['Fixed probability that segmented regions contain 1 '...
    'cell, used only if countClassifier is set to none.']);

sett.pCnt2 = Setting(...
    'name', 'pCnt2',...
    'default', 0.1,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'basic',...
    'visiblefunction', @(x) strcmp(x.Get('countClassifier'), 'none'),...
    'checkfunction', @IsBetween0and1,...
    'tooltip', ['Fixed probability that segmented regions contain 2 or '...
    'more cells, used only if countClassifier is set to none.']);

sett.pCntExtrap = Setting(...
    'name', 'pCntExtrap',...
    'default', 0.25,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'advanced',...
    'checkfunction', @IsBetween0and1,...
    'tooltip', ['Factor by which the the probability is decreased when '...
    'a cell is added to a region containing 2 or more cells.']);

sett.pSplit = Setting(...
    'name', 'pSplit',...
    'default', 0.01,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'basic',...
    'visiblefunction', @(x) strcmp(x.Get('splitClassifier'), 'none') ||...
    isequal(x.Get('TrackSplitPriorChange'),1),...
    'checkfunction', @IsBetween0and1,...
    'tooltip', ['Fixed probability of mitosis in segmented regions, '...
    'used only if splitClassifier is set to none.']);

sett.pDeath = Setting(...
    'name', 'pDeath',...
    'default', 0.01,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'basic',...
    'visiblefunction', @(x) strcmp(x.Get('deathClassifier'), 'none') ||...
    isequal(x.Get('TrackDeathPriorChange'),1),...
    'checkfunction', @IsBetween0and1,...
    'tooltip', ['Fixed probability of apoptosis in segmented regions, '...
    'used only if deathClassifier is set to none.']);

sett.TrackPAppear = Setting(...
    'name', 'TrackPAppear',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'basic',...
    'checkfunction', @IsBetween0and1,...
    'tooltip', 'Fixed probability of random appearance.');

sett.TrackPDisappear = Setting(...
    'name', 'TrackPDisappear',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'basic',...
    'checkfunction', @IsBetween0and1,...
    'tooltip', 'Fixed probability of random disappearance.');

sett.TrackPMig = Setting(...
    'name', 'TrackPMig',...
    'default', 0.01,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction',...
    @(x) strcmp(x.Get('TrackMigLogLikeList'), 'MigLogLikeList_viterbiPaper'),...
    'checkfunction', @IsBetween0and1,...
    'tooltip', 'Probability of migration between an arbitrary detection pair.');

sett.TrackMotionModel = Setting(...
    'name', 'TrackMotionModel',...
    'default', 'none',...
    'type', 'char',...
    'category', 'tracking',...
    'level', 'hidden',...
    'tooltip', ['The name of a mat-file storing a covariance matrix '...
    'for Gaussian migration (or ''none'').']);

% Algorithms used to compute migration probabilities.
migLLL = {...
    'MigLogLikeList_3D'
    'MigLogLikeList_PHD_ISBI_tracks'
    'MigLogLikeList_PHD_ISBI_IMM'
    'MigLogLikeList_PHD_DRO'
    'MigLogLikeList_agree'
    'MigLogLikeList_cellClutter'
    'MigLogLikeList_uniformClutter'
    'MigLogLikeList_uniformClutter_fragments'
    'MigLogLikeList_viterbiPaper'
    'MigLogLikeList_Jaccard'};
sett.TrackMigLogLikeList = Setting(...
    'name', 'TrackMigLogLikeList',...
    'default', 'MigLogLikeList_uniformClutter',...
    'alternatives_development', migLLL,...
    'type', 'choice',...
    'category', 'tracking',...
    'level', 'development',...
    'tooltip', ['Algorithm used for estimation of probabilities of '...
    'migration between segmented regions.']);

gmMigLogLikeLists = {...
    'MigLogLikeList_PHD_ISBI_tracks'
    'MigLogLikeList_PHD_ISBI_IMM'
    'MigLogLikeList_PHD_DRO'};

gmModels = {...
    'ConstantPosition'
    'ConstantVelocity'
    'ConstantVelocity_DRO'
    'ConstantAcceleration_DRO'};
sett.TrackGMModel = Setting(...
    'name', 'TrackGMModel',...
    'default', 'ConstantPosition',...
    'alternatives_development', gmModels,...
    'type', 'choice',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'tooltip', 'Motion model for GM-PHD tracking.');

sett.TrackGMpS = Setting(...
    'name', 'TrackGMpS',...
    'default', 0.95,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsBetween0and1,...
    'tooltip', 'Probability that a target is present in the following frame.');

sett.TrackGMpD = Setting(...
    'name', 'TrackGMpD',...
    'default', 0.95,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsBetween0and1,...
    'tooltip', 'Probability of detection.');

sett.TrackGMkappa = Setting(...
    'name', 'TrackGMkappa',...
    'default', 1E-6,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Clutter intensity.');

sett.TrackGMgamma = Setting(...
    'name', 'TrackGMgamma',...
    'default', 1E-6,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Intensity of appearing targets.');

sett.TrackGMn = Setting(...
    'name', 'TrackGMn',...
    'default', 50,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'The number of targets per image.');

sett.TrackGMw_thresh = Setting(...
    'name', 'TrackGMw_thresh',...
    'default', 1E-3,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Threshold on weights of Gaussian Mixture components.');

sett.TrackGMKLdiv_thresh = Setting(...
    'name', 'TrackGMKLdiv_thresh',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Threshold on (maximum) KL-divergence between pairs of '...
    'Gaussian mixture components.']);

sett.TrackGMJmax = Setting(...
    'name', 'TrackGMJmax',...
    'default', 1E6,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsPositiveInteger,...
    'tooltip', 'The maximum number of Gaussian Mixture components.');

sett.TrackGMStdX = Setting(...
    'name', 'TrackGMStdX',...
    'default', 2,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Standard deviation of Brownian motion.');

sett.TrackGMStdV = Setting(...
    'name', 'TrackGMStdV',...
    'default', 4,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Standard deviation of target velocity along one axis.');

sett.TrackGMr = Setting(...
    'name', 'TrackGMr',...
    'default', 2,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Standard deviation of detection error along one axis.');

sett.TrackGMq = Setting(...
    'name', 'TrackGMq',...
    'default', 1.25,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) any(strcmp(gmMigLogLikeLists, x.Get('TrackMigLogLikeList'))),...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Scale factor for process noise matrix in the constant velocity model.');

sett.TrackSplitPriorChange = Setting(...
    'name', 'TrackSplitPriorChange',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) ~strcmp(x.Get('splitClassifier'), 'none'),...
    'checkfunction', @IsBinary,...
    'tooltip', ['Set this to 1 to use pSplit as the new mitosis prior '...
    'in the mitosis classifier.']);

sett.TrackDeathPriorChange = Setting(...
    'name', 'TrackDeathPriorChange',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) ~strcmp(x.Get('deathClassifier'), 'none'),...
    'checkfunction', @IsBinary,...
    'tooltip', ['Set this to 1 to use pDeath as the new apoptosis '...
    'prior in the apoptosis classifier.']);

sett.TrackDeathShift = Setting(...
    'name', 'TrackDeathShift',...
    'default', 2E-5,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsNumeric,...
    'tooltip', 'Factor multiplying the probability of apoptosis.');

sett.TrackMaxDeathProb = Setting(...
    'name', 'TrackMaxDeathProb',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsNumeric,...
    'tooltip', ['Maximum apoptosis probability after classification. '...
    'Higher classification probabilities will be truncated.']);

sett.TrackMaxMigScore = Setting(...
    'name', 'TrackMaxMigScore',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsNumeric,...
    'tooltip', 'Maximum score associated with migration.');

sett.TrackMigInOut = Setting(...
    'name', 'TrackMigInOut',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'advanced',...
    'checkfunction', @IsBinary,...
    'tooltip', ['Set this to 1, to allow cells to enter and leave the '...
    'field of view through migration.']);

sett.TrackNumNeighbours = Setting(...
    'name', 'TrackNumNeighbours',...
    'default', 3,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsPositiveInteger,...
    'tooltip', ['The number of neighboring detections that are '...
    'considered for each detection during track linking.']);

sett.TrackSingleIdleState = Setting(...
    'name', 'TrackSingleIdleState',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsBinary,...
    'tooltip', ['If this is 1, the track linking algorithm can add '...
    'multiple track fragments in the same iteration.']);

sett.TrackBipartiteMatch = Setting(...
    'name', 'TrackBipartiteMatch',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsBinary,...
    'tooltip', ['If this is set to 1, bipartite matching will be used '...
    'to optimize track links when regions are split after tracking.']);

sett.TrackFalsePos = Setting(...
    'name', 'TrackFalsePos',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @(aStr) str2double(aStr) == 0 ||...
    str2double(aStr) == 1 || str2double(aStr) == 2,...
    'tooltip', ['If this is 1, false positive detections will be '...
    'linked into false positive tracks.']);

sett.TrackSaveFPAsCells = Setting(...
    'name', 'TrackSaveFPAsCells',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsBinary,...
    'tooltip', 'If this is 1, false positive cells are saved as normal cells.');

sett.TrackCentroidOffset = Setting(...
    'name', 'TrackCentroidOffset',...
    'default', 0',...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'hidden',...
    'checkfunction', @IsNumeric,...
    'tooltip', ['Offset in pixels, applied to the centroid positions, '...
    'in direction of motion.']);

sett.TrackMergeWatersheds = Setting(...
    'name', 'TrackMergeWatersheds',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'advanced',...
    'checkfunction', @IsBinary,...
    'tooltip', ['If this is set to 1, regions without cells will be '...
    'merged into adjacent regions with cells after the track linking step.']);

sett.TrackMergeOverlapMaxIter = Setting(...
    'name', 'TrackMergeOverlapMaxIter',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsNonNegativeInteger,...
    'tooltip', 'The number of iterations of overlapping region merging.');

sett.TrackMergeOverlapThresh = Setting(...
    'name', 'TrackMergeOverlapThresh',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) isnumeric(x.Get('TrackMergeOverlapMaxIter')) &&...
    x.Get('TrackMergeOverlapMaxIter') > 0,...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'The overlap threshold for merging of overlapping regions.');

sett.TrackMergeOverlapDeltaT = Setting(...
    'name', 'TrackMergeOverlapDeltaT',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'visiblefunction', @(x) isnumeric(x.Get('TrackMergeOverlapMaxIter')) &&...
    x.Get('TrackMergeOverlapMaxIter') > 0,...
    'checkfunction', @IsPositiveInteger,...
    'tooltip', ['The maximum time difference in frames across which '...
    'overlapping regions are merged.']);

sett.TrackMergeBrokenMaxArea = Setting(...
    'name', 'TrackMergeBrokenMaxArea',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['Maximum area of regions that can be merged because '...
    'they overlap with the same region in an adjacent image.']);

sett.TrackMergeBrokenRatio = Setting(...
    'name', 'TrackMergeBrokenRatio',...
    'default', 0.75,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsNonNegative,...
    'tooltip', ['The amount of overlap (as a fraction of the total '...
    'area) necessary to merge regions which overlap with the same '...
    'region in an adjacent image.']);

sett.foiErosion = Setting(...
    'name', 'foiErosion',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsNonNegativeInteger,...
    'tooltip', ['Width of a pixel border around the image where cells '...
    'will be removed.']);

sett.TrackSaveIterations = Setting(...
    'name', 'TrackSaveIterations',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsBinary,...
    'tooltip', ['Set this to 1 to save intermediate tracking '...
    'information for debug purposes.']);

sett.TrackSavePTC = Setting(...
    'name', 'TrackSavePTC',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsBinary,...
    'tooltip', ['Save tracking results in the format of the 2012 ISBI '...
    'Particle Tracking Challenge.']);

sett.TrackSaveCTC = Setting(...
    'name', 'TrackSaveCTC',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'advanced',...
    'checkfunction', @IsBinary,...
    'tooltip', ['Save tracking results in the format of the 2014 ISBI '...
    'Cell Tracking Challenge.']);

sett.TrackSaveCSB = Setting(...
    'name', 'TrackSaveCSB',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'advanced',...
    'checkfunction', @IsBinary,...
    'tooltip', ['Save the raw segmentation result in the format of the '...
    '2019 ISBI Cell Segmentation Challenge.']);

sett.TrackSaveMat = Setting(...
    'name', 'TrackSaveMat',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'advanced',...
    'checkfunction', @IsBinary,...
    'tooltip', ['Save the tracking results in the MATLAB mat-format. '...
    'This can fail for large datasets.']);

sett.TrackEvaluateCTC = Setting(...
    'name', 'TrackEvaluateCTC',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsBinary,...
    'tooltip', 'Evaluate TRA and SEG after tracking.');

sett.TrackSelectFromGT = Setting(...
    'name', 'TrackSelectFromGT',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsBinary,...
    'tooltip', ['Select cells that were tracked manually in CTC and '...
    'save to a separate version.']);

sett.TrackRelinkSelectedCells = Setting(...
    'name', 'TrackRelinkSelectedCells',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'tracking',...
    'level', 'development',...
    'checkfunction', @IsBinary,...
    'visiblefunction', @(x) x.Get('TrackSelectFromGT') == 1,...
    'tooltip', ['Relink and extend cells that have CTC ground truths, '...
    'to the end of the image sequence.']);

% Analysis settings.

sett.condition = Setting(...
    'name', 'condition',...
    'default', 'Unspecified',...
    'type', 'char',...
    'category', 'analysis',...
    'level', 'basic',...
    'tooltip', 'Names of the experimental conditions.');

sett.pixelSize = Setting(...
    'name', 'pixelSize',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'analysis',...
    'level', 'basic',...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Pixel size of the camera sensor in micrometers.');

sett.magnification = Setting(...
    'name', 'magnification',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'analysis',...
    'level', 'basic',...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Magnification of the microscope objective.');

sett.dT = Setting(...
    'name', 'dT',...
    'default', 1,...
    'type', 'numeric',...
    'category', 'analysis',...
    'level', 'basic',...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Time in seconds between image sequence frames.');

sett.startT = Setting(...
    'name', 'startT',...
    'default', 0,...
    'type', 'numeric',...
    'category', 'analysis',...
    'level', 'advanced',...
    'checkfunction', @IsNonNegative,...
    'tooltip', 'Time in hours when the imaging was started.');

sett.authorStr = Setting(...
    'name', 'authorStr',...
    'default', '',...
    'type', 'char',...
    'category', 'analysis',...
    'level', 'advanced',...
    'tooltip', 'String with names and emails of the authors of data analysis pdfs.');

% Check that the settings definitions are consistent.
fields = fieldnames(sett);
cellSettings = struct2cell(sett);
oSettingsNames = cellfun(@(x)x.name, cellSettings, 'UniformOutput', false);
assert(length(fields) == length(oSettingsNames))
for i = 1:length(fields)
    s = sett.(oSettingsNames{i});
    
    assert(any(strcmp({'basic', 'advanced', 'development', 'hidden'}, s.level)),...
        sprintf('Unknown oSettings level %s', s.level))
end

% Convert the struct to a Map.
output = Map(sett);

% Cache the output for next time the function is called.
oSettings = output.Clone();
end

function oOk = IsBinary(aStr)
% Returns true if the input string is 0 or 1.

oOk = str2double(aStr) == 0 || str2double(aStr) == 1;
end

function oOk = IsPositiveIntegerArray(aStr, aMinLength, aMaxLength)
% Checks if a string is an integer array of correct length.
%
% Inputs:
% aStr - String.
% aMinLength - Shortest allowed length of the array.
% aMaxLength - Longest allowed length of the array.
%
% Outputs:
% oOk - True if aStr is an integer array of correct length.

num = str2num(aStr); %#ok<ST2NM>
oOk = all(num == round(num)) && all(num > 0) &&...
    length(num) >= aMinLength && length(num) <= aMaxLength;
end

function oOk = IsPositiveArray(aStr, aMinLength, aMaxLength)
% Checks if a string is a positive numeric array of correct length.
%
% Inputs:
% aStr - String.
% aMinLength - Shortest allowed length of the array.
% aMaxLength - Longest allowed length of the array.
%
% Outputs:
% oOk - True if aStr is a positive numeric array of correct length.

num = str2num(aStr); %#ok<ST2NM>
oOk = all(num > 0) && length(num) >= aMinLength && length(num) <= aMaxLength;
end

function oOk = IsNonNegativeIntegerArray(aStr, aMinLength, aMaxLength)
% Checks if a string is a nonnegative integer array of correct length.
%
% Inputs:
% aStr - String.
% aMinLength - Shortest allowed length of the array.
% aMaxLength - Longest allowed length of the array.
%
% Outputs:
% oOk - True if aStr is a nonnegative integer array of correct length.

num = str2num(aStr); %#ok<ST2NM>
oOk = all(num == round(num)) && all(num >= 0) &&...
    length(num) >= aMinLength && length(num) <= aMaxLength;
end

function oOk = IsNonNegativeArray(aStr, aMinLength, aMaxLength)
% Checks if a string is a nonnegative numeric array of correct length.
%
% Inputs:
% aStr - String.
% aMinLength - Shortest allowed length of the array.
% aMaxLength - Longest allowed length of the array.
%
% Outputs:
% oOk - True if aStr is a nonnegative numeric array of correct length.


num = str2num(aStr); %#ok<ST2NM>
oOk = all(num >= 0) && length(num) >= aMinLength && length(num) <= aMaxLength;
end

function oOk = IsPositive(aStr)
% Returns true if the input string is a positive scalar.

oOk = str2double(aStr) > 0;
end

function oOk = IsNonNegative(aStr)
% Returns true if the input string is a nonnegative scalar.

oOk = str2double(aStr) >= 0;
end

function oOk = IsPositiveInteger(aStr)
% Returns true if the input string is a positive integer scalar.

oOk = str2double(aStr) > 0 && all(str2num(aStr) == round(str2num(aStr))); %#ok<ST2NM>
end

function oOk = IsNonNegativeInteger(aStr)
% Returns true if the input string is a nonnegative integer scalar.

oOk = str2double(aStr) >= 0 && all(str2num(aStr) == round(str2num(aStr))); %#ok<ST2NM>
end

function oOk = IsBetween0and1(aStr)
% Returns true if the input string is a value between 0 and 1.
%
% 0 and 1 are both included in the interval.

oOk = str2double(aStr) >= 0 && str2double(aStr) <= 1;
end

function oOk = IsNumeric(aStr)
% Returns true if the input string is a scalar.

oOk = ~isnan(str2double(aStr));
end

function oOk = NotLoad(aX)
% Returns true if a new segmentation will be computed.
%
% The function returns false if segmentation results from an earlier run
% are loaded, or if a segmentation is loaded from label images generated
% using some other software.
%
% Inputs:
% aX - ImageParameters object or ImageData object with settings
%      values for all settings.
%
% Outputs:
% oOk - True if a new segmentation will be computed.

oOk = strcmp(aX.Get('SegOldVersion'), 'none') &&...
    ~strcmp(aX.Get('SegAlgorithm'), 'Segment_import');
end

function oOk = NotEmpty(aX)
% Returns true if the input string is not empty.

oOk = ~isempty(aX);
end

function oAlt = Conditional(aCondition, aAlt1, aAlt2)
% Selects one out of two alternatives based on a binary input.
%
% Inputs:
% aCondition - Binary value deciding if the first or the second alternative
%              should be returned. The input argument is often a
%              comparison.
% aVal1 - The first alternative.
% aVal2 - The second alternative.
%
% Outputs:
% oAlt - Equal to aAlt1 if aCondition is true and aAlt2 if
%        aCondition is false.

if aCondition
    oAlt = aAlt1;
else
    oAlt = aAlt2;
end
end

function  oVal = GetIndex(aArray, aIndex)
% Function for indexing into an array or a cell array.
%
% This function replaces indexing using () or {}, and can avoid creating a
% dummy variable when indexing is done on an array or cell array returned
% by a call to a function.
%
% Inputs:
% aArray - Array to be indexed.
% aIndex - Scalar index to be returned.
%
% Outputs:
% oVal - aArray(aIndex), or [] if aIndex is outside the array.

if aIndex > length(aArray)
    oVal = [];
    return
end

if iscell(aArray)
    oVal = aArray{aIndex};
else
    oVal = aArray(aIndex);
end
end